# algo-strategies-mini-project--Ashu
# Lab Assignment 1 â€“ Algorithm Foundations

Course: Design and Analysis of Algorithms Lab (ENCA351)
Program: BCA (AI & DS), Semester V
Session: 2025â€“26
Faculty: Dr. Aarti Sangwan
Student: Ashu (Roll No. 2301201105)

## ðŸ“˜ Overview

This repository contains the implementation, analysis, and comparison of foundational algorithms as part of Lab Assignment 1: Algorithm Foundations.
The document explores recursion, dynamic programming, divide-and-conquer sorting algorithms, and searching techniques.
Each algorithm includes:

Python implementation

Time and space complexity analysis

Performance outputs

Visual or tabular comparisons (where applicable)

## ðŸ§® Tasks & Implemented Algorithms
## 1. Fibonacci Algorithms
(i) NaÃ¯ve Recursive Fibonacci

Uses plain recursion

Time Complexity: O(2^n)

Space Complexity: O(n)

Very slow for large values of n due to repetitive recomputation.

(ii) Dynamic Programming Fibonacci

Uses memoization or tabulation

Time Complexity: O(n)

Space Complexity: O(n)

Highly efficient for large inputs.

(iii) Fibonacci Comparison

Plots/outputs comparing recursive vs DP performance.

Highlights exponential vs linear growth differences.

## 2. Binary Search

Efficient searching on sorted arrays

Time Complexity: O(log n)

Space Complexity: O(1)

Demonstrated through sample outputs and dry-run behavior.

## 3. Bubble Sort

Repeated swapping of adjacent elements

Time Complexity: O(nÂ²)

Space Complexity: O(1)

Suitable only for small datasets.

## 4. Selection Sort

Selects the minimum element in each pass

Time Complexity: O(nÂ²)

Space Complexity: O(1)

Deterministic and in-place.

## 5. Insertion Sort

Inserts elements into a sorted portion of the array

Time Complexity: O(nÂ²)

Space Complexity: O(1)

Performs well on nearly sorted lists.

## 6. Merge Sort

Divide-and-conquer algorithm

Time Complexity: O(n log n)

Space Complexity: O(n)

Stable and efficient for large datasets.

## 7. Quick Sort

Divide-and-conquer with partitioning

Time Complexity:

Best/Average: O(n log n)

Worst: O(nÂ²)

Space Complexity: O(log n)

Very fast in practice; unstable but widely used.

## 8. Comprehensive Algorithm Comparison

A final table summarizes complexities and characteristics of all algorithms:

<img width="489" height="316" alt="image" src="https://github.com/user-attachments/assets/897b1229-c263-44ae-845c-2100e673cc89" />

ðŸ“„ File Included

Lab_Assignment_1_Algo_report.pdf â€” Full documentation, outputs, complexity plots, and code execution results.

ðŸ§  Purpose

This assignment builds a strong foundation for analyzing algorithm performance through:

Different design paradigms

Complexity reasoning

Practical execution measurements

Comparative evaluation of classic algorithms
